/**
 * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
 */
/**
 * 
 这个问题可以通过动态规划来解决。目标是找到从网格的左上角 (0, 0) 到右下角 (m-1, n-1) 的所有可能路径数。在任何位置 (i, j)，机器人只能从 (i-1, j) 或 (i, j-1) 移动过来。

动态规划思路：
创建一个二维数组 dp，其中 dp[i][j] 表示从起点到达位置 (i, j) 的路径总数。
初始化边界条件：在第一行和第一列的路径数都为 1，因为机器人只能向右或向下移动，没有其他选择。
对于其他位置 (i, j)，路径总数为从左侧的格子 (i, j-1) 和上侧的格子 (i-1, j) 的路径数之和，即 dp[i][j] = dp[i-1][j] + dp[i][j-1]。
最终结果就是 dp[m-1][n-1]。

 */
var uniquePaths = function (m, n) {
  // 创建一个二维数组，初始时所有值都为 1
  let dp = Array(m)
    .fill()
    .map(() => Array(n).fill(1))

  // 填充二维数组，从 (1,1) 开始
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      // 当前格子的路径数是来自上方和左方格子的路径数之和
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }

  // 返回到达右下角的路径总数
  return dp[m - 1][n - 1]
}
/**
 * 代码解释
初始化二维数组 dp：我们创建一个大小为 m x n 的二维数组，每个位置初始化为 1。因为在第一行和第一列上的位置只能有一种路径到达（一直向右或一直向下）。

动态规划计算路径数：

从 (1, 1) 开始，依次计算每个位置的路径数，路径数等于其上方格子的路径数加上左侧格子的路径数。
dp[i][j] = dp[i-1][j] + dp[i][j-1] 表示从左侧或上方移动到 (i, j) 的路径数。
返回结果：最终返回 dp[m-1][n-1]，即到达右下角的路径总数。

总结
该算法的时间复杂度为 O(m * n)，空间复杂度为 O(m * n)。通过动态规划，我们有效地计算了从左上角到右下角的所有可能路径。
 */
