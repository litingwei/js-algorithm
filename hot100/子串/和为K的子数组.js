/**
 * 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
 * 子数组是数组中元素的连续非空序列。
 */
/**
 *
 *
 *可以使用前缀和和哈希表的组合方法来高效解决这个问题。前缀和是指数组中从第一个元素到当前元素的累加和。利用前缀和和哈希表，我们可以在 O(n) 时间复杂度内完成计算。
 *具体思路如下：
 *使用一个哈希表来存储前缀和出现的次数。
 *遍历数组，计算当前的前缀和，并通过前缀和判断是否存在符合条件的子数组。
 *如果当前的前缀和减去 k 在哈希表中出现过，说明存在一个或多个子数组的和为 k。
 *更新哈希表中前缀和的出现次数。
 */
/**
 * 解释
 * 初始化:
以下是算法的工作原理：

我们使用一个变量 sum 来保存当前的累积和。
我们使用一个 Map 对象 map 来存储每个累积和出现的次数。
我们初始化 map 使得 0 出现了一次，这是为了处理从数组开头开始的子数组。
我们遍历数组，对于每个元素：

更新累积和 sum
检查 map 中是否存在 sum - k，如果存在，就将其出现的次数加到 count 上
更新 map 中 sum 的出现次数

这个算法的时间复杂度是 O(n)，其中 n 是数组的长度。空间复杂度也是 O(n)，因为在最坏的情况下，map 可能需要存储所有可能的累积和。
 */
function subarraySum(nums, k) {
  let count = 0
  let sum = 0
  const map = new Map()
  map.set(0, 1) // 初始化map，处理从数组开头开始的子数组

  for (let i = 0; i < nums.length; i++) {
    sum += nums[i]
    if (map.has(sum - k)) {
      count += map.get(sum - k)
    }
    map.set(sum, (map.get(sum) || 0) + 1)
  }

  return count
}

// 测试代码
const nums = [1, 1, 1]
const k = 2
console.log(subarraySum(nums, k)) // 输出: 2
