/**
 * 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
 */
/**
 * 这个问题可以看作是一个经典的「0-1 背包问题」。我们需要判断能否从给定的数组 nums 中选择一些数字，使它们的和等于整个数组和的一半（target）。如果可以做到，那么我们可以将数组分成两个子集，使它们的和相等。

具体步骤如下：

求和判断：首先计算数组的总和。如果总和是奇数，直接返回 false，因为奇数无法平分。
目标值：如果总和是偶数，我们的目标就是检查是否可以从数组中选择一些数字，使其和等于总和的一半。
动态规划：使用动态规划来解决问题。我们定义一个一维数组 dp，其中 dp[j] 表示是否可以用前 i 个数字凑成和为 j 的子集。
状态转移：遍历数组中的每一个数字 num，并倒序更新 dp 数组，确保每个数字只被使用一次。

 */
var canPartition = function (nums) {
  // 计算数组的总和
  const sum = nums.reduce((acc, curr) => acc + curr, 0)

  // 如果总和是奇数，则无法平分，直接返回 false
  if (sum % 2 === 1) return false

  // 目标是总和的一半，即我们需要找到是否有子集的和等于 target
  const target = sum / 2

  // 创建一个数组 dp，初始化为 0，用于记录可以形成的和
  const dp = new Array(target + 1).fill(0)

  // 遍历数组中的每个数字
  for (let i = 0; i < nums.length; i++) {
    // 倒序遍历 dp 数组，确保每个数字只被使用一次
    for (let j = target; j >= nums[i]; j--) {
      // 更新 dp 数组：比较当前值和选择当前数字后的新值，取较大者
      dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i])
    }
  }

  // 如果 dp[target] 等于 target，说明找到了一个子集，其和为 target
  if (dp[target] === target) return true

  // 否则，返回 false
  return false
}
/**
 * 代码解释
求和与判断：首先使用 reduce 函数计算数组的总和。然后判断总和是否为奇数，如果是，直接返回 false。
初始化 dp 数组：创建一个大小为 target + 1 的 dp 数组，用于记录可能的和。初始值全部为 0。
动态规划：遍历数组中的每个数字，并倒序更新 dp 数组。倒序是为了避免在同一轮循环中重复使用相同的元素。
判断是否能分割：最后，通过判断 dp[target] 是否等于 target 来决定是否可以将数组分成两个和相等的子集。
 */
