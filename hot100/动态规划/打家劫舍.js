/**
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
 */
/**
 * 问题分析：

每个房屋内都有一定金额的现金。
不能偷窃相邻的两间房屋，否则会触发报警。
目标是找到能够偷窃的最大金额。
解法： 假设 dp[i] 表示偷窃到第 i 间房屋时能够获得的最大金额。那么：

如果偷窃第 i 间房屋，那么就不能偷窃第 i-1 间房屋，因此 dp[i] = nums[i] + dp[i-2]。
如果不偷窃第 i 间房屋，那么 dp[i] = dp[i-1]。
因此，状态转移方程可以写成： 
dp[i]=max(dp[i−1],nums[i]+dp[i−2])

为了更好地理解：

dp[i-1]：表示不偷窃第 i 间房屋时的最大金额。
nums[i] + dp[i-2]：表示偷窃第 i 间房屋以及第 i-2 间房屋时的最大金额。
边界条件：

dp[0]：只有一间房屋时，最大金额为 nums[0]。
dp[1]：两间房屋时，最大金额为 max(nums[0], nums[1])。

 */
var rob = function (nums) {
  const n = nums.length
  if (n === 0) return 0 // 没有房屋
  if (n === 1) return nums[0] // 只有一间房屋
  if (n === 2) return Math.max(nums[0], nums[1]) // 只有两间房屋

  let dp = new Array(n).fill(0)
  dp[0] = nums[0]
  dp[1] = Math.max(nums[0], nums[1])

  // 从第3间房屋开始计算
  for (let i = 2; i < n; i++) {
    dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])
  }

  // 返回最后一个房屋的最大金额
  return dp[n - 1]
}
/**
 * 代码解释与注释
dp[0]：只有一间房屋时，偷窃的最大金额就是这间房屋内的金额 nums[0]。
dp[1]：如果有两间房屋，最大金额是这两间房屋中金额较大的那一间。
dp[i]：对于第 i 间房屋，偷窃的最大金额可以是偷窃前面 i-2 间房屋并加上当前房屋金额，或者直接选择不偷窃当前房屋，保留之前的最大金额。
最后，dp[n-1] 存储了偷窃到最后一间房屋时的最大金额。
 */
