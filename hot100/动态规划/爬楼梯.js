/**
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 */
/**
 * 这是一个经典的动态规划问题。目标是找到到达楼顶的不同方法数，而每次你可以爬 1 个或 2 个台阶。为了计算到达第 n 阶的方法数，可以利用之前的结果逐步构建解决方案。

动态规划思路：到达第 i 阶的方法数是到达第 i-1 阶和到达第 i-2 阶的方法数之和。因为你可以从 i-1 阶迈一步到达第 i 阶，或者从 i-2 阶迈两步到达第 i 阶。

初始条件：到达第 1 阶的方法数是 1（因为只能迈一步），到达第 2 阶的方法数是 2（因为可以直接迈两步，或者先迈一步，再迈一步）。
 */
var climbStairs = function (n) {
  let dp = [] // 初始化一个空数组，用于存储到达每一阶的方法数
  dp[1] = 1 // 设置初始条件：到达第 1 阶的方法数为 1
  dp[2] = 2 // 设置初始条件：到达第 2 阶的方法数为 2

  // 从第 3 阶开始，计算到达每一阶的方法数
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] // 动态规划递推公式：到达第 i 阶的方法数等于到达第 i-1 阶和第 i-2 阶的方法数之和
  }

  return dp[n] // 返回到达第 n 阶的方法数
}
/**
 * 总结
这个算法使用动态规划来解决问题，将问题分解成若干子问题，并利用之前的子问题结果构建解决方案。时间复杂度为 O(n)，空间复杂度也为 O(n)。
 */
