/**
 * 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。*/
// 这个问题可以通过修改二分查找算法来解决，因为旋转后的数组可以看作是两个有序部分，最小值就是两个有序部分的分界点。

/**
 * @param {number[]} nums - 旋转后的升序数组
 * @return {number} - 数组中的最小元素
 */
function findMin(nums) {
  // 如果数组为空，返回null或抛出异常
  if (nums.length === 0) return null

  // 如果只有一个元素，直接返回该元素
  if (nums.length === 1) return nums[0]

  // 如果数组没有被旋转或旋转了n次（首元素小于尾元素），直接返回首元素
  if (nums[0] < nums[nums.length - 1]) return nums[0]

  let left = 0
  let right = nums.length - 1

  while (left < right) {
    // 计算中间位置
    const mid = Math.floor((left + right) / 2)

    // 如果中间元素大于右边元素，说明最小值在右半部分
    if (nums[mid] > nums[right]) {
      left = mid + 1
    }
    // 如果中间元素小于右边元素，说明最小值在左半部分（包括mid）
    else {
      right = mid
    }

    // 当左右指针相邻时，返回较小的那个数
    if (right - left === 1) {
      return Math.min(nums[left], nums[right])
    }
  }

  // 当左右指针重合时，返回该位置的元素
  return nums[left]
}

// 测试用例
console.log(findMin([3, 4, 5, 1, 2])) // 输出: 1
console.log(findMin([4, 5, 6, 7, 0, 1, 2])) // 输出: 0
console.log(findMin([11, 13, 15, 17])) // 输出: 11
console.log(findMin([2, 1])) // 输出: 1
console.log(findMin([1])) // 输出: 1
console.log(findMin([5, 1, 2, 3, 4])) // 输出: 1
console.log(findMin([1, 2, 3, 4, 5])) // 输出: 1

/**
 * 这个解决方案的主要思路是：
 *
1. 特殊情况处理：
 - 空数组：返回 null 或抛出异常
 - 只有一个元素：直接返回该元素
 - 数组没有被旋转或旋转了 n 次：直接返回首元素

2. 使用二分查找的变体：
 - 通过比较中间元素和右边界元素的关系来决定最小值的位置
 - 如果中间元素大于右边元素，说明最小值在右半部分
 - 如果中间元素小于右边元素，说明最小值在左半部分（包括中间元素）

3. 算法的关键点：
 - 使用右边界作为比较对象，因为这样可以确定最小值的位置
 - 当左右指针相邻时，返回两者中的较小值
 - 当左右指针重合时，该位置就是最小值

4. 复杂度分析：
 - 时间复杂度：O(log n)，使用了二分查找
 - 空间复杂度：O(1)，只使用了常数级别的额外空间

5. 边界条件处理：
 - 数组仅有两个元素
 - 数组完全有序（未旋转或旋转 n 次）
 - 数组在中间位置旋转
 - 数组在开始或结束位置附近旋转

算法可以正确处理所有这些情况。如果你需要更多的测试用例或有任何疑问，请告诉我。
*/
