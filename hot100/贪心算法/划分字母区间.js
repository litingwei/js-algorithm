/**
 * 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。


 */
/**
 * 
 * 要解决这个问题，我们需要找到一种方法，将字符串 s 划分为尽可能多的片段，并且保证每个片段中的字母不会出现在其他片段中。这个问题可以使用贪心算法来解决。

解题思路
记录每个字母的最后出现位置：

首先遍历字符串 s，记录每个字母的最后出现位置。这样在划分字符串时，我们能够知道某个片段的结束位置。
划分字符串：

遍历字符串，同时维护一个当前片段的结束位置（end）。
对于当前遍历到的每个字母，更新当前片段的结束位置为该字母的最后出现位置。
当遍历的位置达到当前片段的结束位置时，说明找到了一个片段，可以将其划分出来。
继续划分：

从下一个位置开始，继续寻找下一个片段，直到遍历完整个字符串。} s 
 */
var partitionLabels = function (s) {
  // 记录每个字母最后出现的位置
  let last = new Array(26)
  for (let i = 0; i < s.length; i++) {
    last[s.charCodeAt(i) - 'a'.charCodeAt(0)] = i
  }

  let start = 0
  let end = 0
  const result = []

  for (let i = 0; i < s.length; i++) {
    // 更新当前片段的结束位置
    end = Math.max(end, last[s.charCodeAt(i) - 'a'.charCodeAt(0)])

    // 如果当前索引达到当前片段的结束位置
    if (i === end) {
      result.push(end - start + 1) // 记录片段长度
      start = i + 1 // 更新下一个片段的起始位置
    }
  }

  return result
}
/**
 * 代码解释
记录每个字母的最后出现位置：

使用 last 数组来存储每个字母的最后出现位置。数组的索引是通过字母的 ASCII 值减去 'a' 的 ASCII 值得到的。
遍历字符串：

遍历字符串时，更新当前片段的结束位置 end 为当前字母的最后出现位置。
如果遍历位置 i 到达了 end，表示当前片段可以划分出来了，计算这个片段的长度并加入结果数组。
继续划分：

更新 start 为下一个片段的起始位置，并继续处理剩下的字符串。
示例
假设输入字符串为 s = "ababcbacadefegdehijhklij"：

对于字符 'a'，最后出现的位置是索引 8；
对于字符 'b'，最后出现的位置是索引 5；
对于字符 'c'，最后出现的位置是索引 7；
因此，最初的片段从 0 到 8。
然后从索引 9 开始，继续划分下一个片段，最终得到的划分结果为 [9, 7, 8]。
返回的结果 [9, 7, 8] 表示三个片段的长度。
 */
