/**
 * 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
 */
/**
 * 
解题思路
这个问题是关于判断是否能从数组的第一个元素跳跃到最后一个元素。数组中的每个元素表示在该位置可以跳跃的最大长度。

解题的核心思想是使用贪心算法（Greedy Algorithm）。我们维护一个变量 cover 来表示当前能够跳跃的最远位置，并遍历数组中的每一个元素。如果在遍历的过程中发现 cover 能够到达或超过最后一个元素的下标，则返回 true。如果遍历完所有元素后仍然无法到达最后一个元素，则返回 false。
 */
var canJump = function (nums) {
  // 如果数组长度为1，直接返回true，因为不需要跳跃
  if (nums.length == 1) return true

  // 初始化覆盖范围 cover 为 0
  let cover = 0

  // 遍历数组，从第一个元素到当前能覆盖的最远位置
  for (let i = 0; i <= cover; i++) {
    // 更新当前能跳跃到的最远位置
    cover = Math.max(cover, i + nums[i])

    // 如果能跳到或超过最后一个下标，直接返回 true
    if (cover >= nums.length - 1) return true
  }

  // 如果遍历完数组后仍然无法到达最后一个下标，返回 false
  return false
}
/**
 * 代码解释
特殊情况处理: 如果数组的长度为1，说明已经在最后一个下标，不需要跳跃，直接返回 true。

初始化 cover: 使用变量 cover 来表示当前能跳跃到的最远位置，初始值为0。

遍历数组: 使用 for 循环遍历数组，从第一个元素开始，每次更新 cover 的值为 Math.max(cover, i + nums[i])，即当前位置能跳跃的最远距离。

提前返回: 如果 cover 能够到达或超过数组的最后一个下标，提前返回 true。

遍历结束: 如果遍历结束后 cover 仍然无法到达数组的最后一个下标，返回 false。

通过这种方法，可以在时间复杂度为 O(n) 的情况下判断是否能够到达数组的最后一个下标。
 */
